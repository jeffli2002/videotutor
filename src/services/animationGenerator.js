// Âä®ÁîªÁîüÊàêÊ®°Âùó - Ê†πÊçÆÈóÆÈ¢òÁ±ªÂûãÁîüÊàê‰∏çÂêåÁöÑÂä®ÁîªÂÜÖÂÆπ
import { QuestionAnalyzer } from './questionAnalyzer.js'

export class AnimationGenerator {
  constructor() {
    this.questionAnalyzer = new QuestionAnalyzer()
    this.config = {
      manim: {
        endpoint: 'http://localhost:8002/generate-video'
      }
    }
  }

  // Ê†πÊçÆÈóÆÈ¢òÁ±ªÂûãÁîüÊàêÁõ∏Â∫îÁöÑÂä®Áîª
  async generateAnimation(question, solution, script, language = 'zh') {
    const analysis = this.questionAnalyzer.analyzeQuestionType(question)
    
    if (analysis.isConcreteProblem) {
      return this.generateConcreteProblemAnimation(question, solution, script, language, analysis)
    } else if (analysis.isTheoreticalQuestion) {
      return this.generateTheoreticalQuestionAnimation(question, solution, script, language, analysis)
    } else {
      return this.generateMixedAnimation(question, solution, script, language, analysis)
    }
  }

  // ÁîüÊàêÂÖ∑‰ΩìÊ±ÇËß£ÈóÆÈ¢òÁöÑÂä®Áîª
  async generateConcreteProblemAnimation(question, solution, script, language, analysis) {
    console.log('üé¨ ÁîüÊàêÂÖ∑‰ΩìÊ±ÇËß£ÈóÆÈ¢òÂä®Áîª...')
    
    const steps = this.extractConcreteSteps(solution, question)
    
    try {
      // ÁîüÊàêManimËÑöÊú¨
      const manimScript = this.buildConcreteProblemManimScript(steps, question)
      
      // Ë∞ÉÁî®ManimÊúçÂä°Âô®ÁîüÊàêËßÜÈ¢ë
      const response = await fetch(this.config.manim.endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          script: manimScript,
          output_name: `concrete_problem_${Date.now()}`,
          question: question
        })
      })
      
      const result = await response.json()
      
      if (result.success && result.video_path) {
        console.log('‚úÖ ÂÖ∑‰ΩìÈóÆÈ¢òÂä®ÁîªÁîüÊàêÊàêÂäü:', result.video_path)
        return [{
          sceneId: 1,
          animationType: 'concrete_problem',
          videoPath: result.video_path,
          duration: Math.max(20, steps.length * 8),
          mathContent: steps.join('; '),
          steps: steps,
          script: script
        }]
      } else {
        console.warn('‚ùå ÂÖ∑‰ΩìÈóÆÈ¢òÂä®ÁîªÁîüÊàêÂ§±Ë¥•:', result.error)
        return this.generateStaticVisuals(question, script)
      }
      
    } catch (error) {
      console.error('‚ùå ÂÖ∑‰ΩìÈóÆÈ¢òÂä®ÁîªÁîüÊàêÂºÇÂ∏∏:', error)
      return this.generateStaticVisuals(question, script)
    }
  }

  // ÁîüÊàêÁêÜËÆ∫Ëß£ÈáäÈóÆÈ¢òÁöÑÂä®Áîª
  async generateTheoreticalQuestionAnimation(question, solution, script, language, analysis) {
    console.log('üé¨ ÁîüÊàêÁêÜËÆ∫Ëß£ÈáäÈóÆÈ¢òÂä®Áîª...')
    
    const concepts = this.extractTheoreticalConcepts(solution, question)
    
    try {
      // ÁîüÊàêManimËÑöÊú¨
      const manimScript = this.buildTheoreticalQuestionManimScript(concepts, question)
      
      // Ë∞ÉÁî®ManimÊúçÂä°Âô®ÁîüÊàêËßÜÈ¢ë
      const response = await fetch(this.config.manim.endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          script: manimScript,
          output_name: `theoretical_question_${Date.now()}`,
          question: question
        })
      })
      
      const result = await response.json()
      
      if (result.success && result.video_path) {
        console.log('‚úÖ ÁêÜËÆ∫ÈóÆÈ¢òÂä®ÁîªÁîüÊàêÊàêÂäü:', result.video_path)
        return [{
          sceneId: 1,
          animationType: 'theoretical_question',
          videoPath: result.video_path,
          duration: Math.max(25, concepts.length * 10),
          mathContent: concepts.join('; '),
          concepts: concepts,
          script: script
        }]
      } else {
        console.warn('‚ùå ÁêÜËÆ∫ÈóÆÈ¢òÂä®ÁîªÁîüÊàêÂ§±Ë¥•:', result.error)
        return this.generateStaticVisuals(question, script)
      }
      
    } catch (error) {
      console.error('‚ùå ÁêÜËÆ∫ÈóÆÈ¢òÂä®ÁîªÁîüÊàêÂºÇÂ∏∏:', error)
      return this.generateStaticVisuals(question, script)
    }
  }

  // ÁîüÊàêÊ∑∑ÂêàÁ±ªÂûãÈóÆÈ¢òÁöÑÂä®Áîª
  async generateMixedAnimation(question, solution, script, language, analysis) {
    console.log('üé¨ ÁîüÊàêÊ∑∑ÂêàÁ±ªÂûãÈóÆÈ¢òÂä®Áîª...')
    
    // Ê†πÊçÆÈóÆÈ¢òÂÜÖÂÆπÂä®ÊÄÅÈÄâÊã©Âä®ÁîªÁ±ªÂûã
    if (question.includes('ÊãâÁ™óÂ∏ò') || question.includes('ÂéüÁêÜ')) {
      return this.generateTheoreticalQuestionAnimation(question, solution, script, language, analysis)
    } else {
      return this.generateConcreteProblemAnimation(question, solution, script, language, analysis)
    }
  }

  // ÊûÑÂª∫ÂÖ∑‰ΩìÈóÆÈ¢òÁöÑManimËÑöÊú¨
  buildConcreteProblemManimScript(steps, question) {
    const stepsStr = JSON.stringify(steps)
    
    return `from manim import *
import warnings
warnings.filterwarnings("ignore")

config.frame_rate = 30
config.pixel_height = 1080
config.pixel_width = 1920
config.background_color = WHITE

class ConcreteProblemScene(Scene):
    def construct(self):
        self.camera.background_color = WHITE
        
        # Ê†áÈ¢ò
        title = Text("Êï∞Â≠¶È¢òÁõÆËß£Á≠î", font_size=32, color=BLUE).to_edge(UP)
        self.play(Write(title), run_time=0.8)
        self.wait(0.3)
        
        # ÊòæÁ§∫È¢òÁõÆ
        question_text = Text("${question.substring(0, 50)}${question.length > 50 ? '...' : ''}", 
                           font_size=20, color=BLACK).next_to(title, DOWN, buff=0.5)
        self.play(Write(question_text), run_time=1.0)
        self.wait(1.0)
        
        # ÊòæÁ§∫Ëß£È¢òÊ≠•È™§
        steps = ${stepsStr}
        max_steps = min(len(steps), 6)
        steps = steps[:max_steps]
        
        previous_text = None
        for i, step_text in enumerate(steps):
            step_num = Text(f"Ê≠•È™§ {i+1}", font_size=24, color=BLUE, weight=BOLD)
            step_num.next_to(question_text, DOWN, buff=1.0)
            
            step_content = self.create_step_content(step_text, step_num)
            
            if previous_text:
                self.play(FadeOut(previous_text), run_time=0.6)
            
            self.play(Write(step_num), run_time=1.0)
            self.play(Write(step_content), run_time=1.2)
            
            wait_time = min(max(3.5, len(step_text) * 0.015), 8.0)
            self.wait(wait_time)
            
            previous_text = VGroup(step_num, step_content)
        
        # ÊÄªÁªì
        if previous_text:
            self.play(FadeOut(previous_text), run_time=0.8)
        
        summary = Text("Ëß£È¢òÂÆåÊàê", font_size=28, color=GREEN, weight=BOLD)
        summary.next_to(question_text, DOWN, buff=1.0)
        self.play(Write(summary), run_time=1.0)
        self.wait(2.0)
    
    def create_step_content(self, text, step_num):
        if len(text) > 80:
            words = text.split(' ')
            lines = []
            current_line = ""
            
            for word in words:
                if (current_line + word).length <= 40:
                    current_line += word + " "
                else:
                    if current_line:
                        lines.append(current_line.strip())
                    current_line = word + " "
            
            if current_line:
                lines.append(current_line.strip())
            
            text_objects = []
            for i, line in enumerate(lines):
                text_obj = Text(line, font_size=18, color=BLACK)
                if i == 0:
                    text_obj.next_to(step_num, DOWN, buff=0.3)
                else:
                    text_obj.next_to(text_objects[i-1], DOWN, buff=0.1)
                text_objects.append(text_obj)
            
            return VGroup(*text_objects)
        else:
            return Text(text, font_size=18, color=BLACK).next_to(step_num, DOWN, buff=0.3)
`
  }

  // ÊûÑÂª∫ÁêÜËÆ∫ÈóÆÈ¢òÁöÑManimËÑöÊú¨
  buildTheoreticalQuestionManimScript(concepts, question) {
    const conceptsStr = JSON.stringify(concepts)
    
    return `from manim import *
import warnings
warnings.filterwarnings("ignore")

config.frame_rate = 30
config.pixel_height = 1080
config.pixel_width = 1920
config.background_color = WHITE

class TheoreticalQuestionScene(Scene):
    def construct(self):
        self.camera.background_color = WHITE
        
        # Ê†áÈ¢ò
        title = Text("Ê¶ÇÂøµÁêÜËß£", font_size=32, color=BLUE).to_edge(UP)
        self.play(Write(title), run_time=0.8)
        self.wait(0.3)
        
        # ÊòæÁ§∫ÈóÆÈ¢ò
        question_text = Text("${question.substring(0, 50)}${question.length > 50 ? '...' : ''}", 
                           font_size=20, color=BLACK).next_to(title, DOWN, buff=0.5)
        self.play(Write(question_text), run_time=1.0)
        self.wait(1.0)
        
        # ÊòæÁ§∫Ê¶ÇÂøµËß£Èáä
        concepts = ${conceptsStr}
        max_concepts = min(len(concepts), 4)
        concepts = concepts[:max_concepts]
        
        previous_text = None
        for i, concept_text in enumerate(concepts):
            concept_num = Text(f"Ê¶ÇÂøµ {i+1}", font_size=24, color=BLUE, weight=BOLD)
            concept_num.next_to(question_text, DOWN, buff=1.0)
            
            concept_content = self.create_concept_content(concept_text, concept_num)
            
            if previous_text:
                self.play(FadeOut(previous_text), run_time=0.6)
            
            self.play(Write(concept_num), run_time=1.0)
            self.play(Write(concept_content), run_time=1.2)
            
            wait_time = min(max(4.0, len(concept_text) * 0.02), 10.0)
            self.wait(wait_time)
            
            previous_text = VGroup(concept_num, concept_content)
        
        # ÊÄªÁªì
        if previous_text:
            self.play(FadeOut(previous_text), run_time=0.8)
        
        summary = Text("Ê¶ÇÂøµÁêÜËß£ÂÆåÊàê", font_size=28, color=GREEN, weight=BOLD)
        summary.next_to(question_text, DOWN, buff=1.0)
        self.play(Write(summary), run_time=1.0)
        self.wait(2.0)
    
    def create_concept_content(self, text, concept_num):
        if len(text) > 100:
            words = text.split(' ')
            lines = []
            current_line = ""
            
            for word in words:
                if (current_line + word).length <= 50:
                    current_line += word + " "
                else:
                    if current_line:
                        lines.append(current_line.strip())
                    current_line = word + " "
            
            if current_line:
                lines.append(current_line.strip())
            
            text_objects = []
            for i, line in enumerate(lines):
                text_obj = Text(line, font_size=18, color=BLACK)
                if i == 0:
                    text_obj.next_to(concept_num, DOWN, buff=0.3)
                else:
                    text_obj.next_to(text_objects[i-1], DOWN, buff=0.1)
                text_objects.append(text_obj)
            
            return VGroup(*text_objects)
        else:
            return Text(text, font_size=18, color=BLACK).next_to(concept_num, DOWN, buff=0.3)
`
  }

  // ÊèêÂèñÂÖ∑‰ΩìËß£È¢òÊ≠•È™§
  extractConcreteSteps(solution, question) {
    let steps = []
    
    if (Array.isArray(solution)) {
      steps = solution
    } else if (typeof solution === 'string') {
      const stepMatches = solution.match(/(\d+)[.„ÄÅ\)]\s*\*\*([^*]+)\*\*\s*([^\n]+)/g)
      if (stepMatches) {
        steps = stepMatches.map(match => {
          const content = match.replace(/^\d+[.„ÄÅ\)]\s*\*\*([^*]+)\*\*\s*/, '$1Ôºö')
          return content.trim()
        })
      } else {
        const lines = solution.split('\n').filter(line => 
          line.trim().length > 10 && 
          /[\+\-\=\√ó\√∑\‚àö\d]/.test(line) &&
          !line.includes('**ÊúÄÁªàÁ≠îÊ°à') &&
          !line.includes('**È™åËØÅ')
        )
        steps = lines.slice(0, 6)
      }
    }
    
    return steps.filter(step => 
      step.length > 10 && 
      (/\d/.test(step) || /[\+\-\=\√ó\√∑\‚àö]/.test(step) || /(ËÆ°ÁÆó|Ê±ÇËß£|ÂåñÁÆÄ|Â±ïÂºÄ|ÂêàÂπ∂|ÁßªÈ°π|‰ª£ÂÖ•)/.test(step))
    )
  }

  // ÊèêÂèñÁêÜËÆ∫Ê¶ÇÂøµ
  extractTheoreticalConcepts(solution, question) {
    let concepts = []
    
    if (typeof solution === 'string') {
      const paragraphs = solution.split('\n\n').filter(p => 
        p.trim().length > 20 && 
        (p.includes('ÂéüÁêÜ') || p.includes('Ê¶ÇÂøµ') || p.includes('ÁêÜËß£') || p.includes('ÊºîÁ§∫'))
      )
      concepts = paragraphs.slice(0, 4)
    }
    
    if (concepts.length === 0) {
      if (question.includes('ÊãâÁ™óÂ∏ò')) {
        concepts = [
          'ÊãâÁ™óÂ∏òÂéüÁêÜÊòØÂá†‰ΩïÂ≠¶‰∏≠ÁöÑ‰∏Ä‰∏™ÈáçË¶ÅÊ¶ÇÂøµÔºåÂÆÉÂ±ïÁ§∫‰∫Ü‰∏âËßíÂΩ¢Èù¢ÁßØÁöÑ‰∏çÂèòÊÄß',
          'ÂΩìÊàë‰ª¨Ê≤øÁùÄ‰∏âËßíÂΩ¢ÁöÑ‰∏≠Á∫øÂâ™ÂºÄÂπ∂ÈáçÊñ∞ÁªÑÂêàÊó∂ÔºåÈù¢ÁßØ‰øùÊåÅ‰∏çÂèò',
          'Ëøô‰∏™ÂéüÁêÜÂ∏ÆÂä©Êàë‰ª¨ÁêÜËß£Âá†‰ΩïÂèòÊç¢‰∏≠ÁöÑÈù¢ÁßØÂÆàÊÅí',
          'ÈÄöËøáÂä®ÁîªÊºîÁ§∫ÔºåÊàë‰ª¨ÂèØ‰ª•Áõ¥ËßÇÂú∞ÁúãÂà∞Ëøô‰∏™ÂèòÊç¢ËøáÁ®ã'
        ]
      } else {
        concepts = [
          'ËÆ©Êàë‰ª¨ÂÖàÁêÜËß£Ëøô‰∏™Êï∞Â≠¶Ê¶ÇÂøµÁöÑÂü∫Êú¨Âê´‰πâ',
          'ÈÄöËøáÂÖ∑‰ΩìÁöÑ‰æãÂ≠êÊù•Âä†Ê∑±ÁêÜËß£',
          'ÊéåÊè°Ëøô‰∏™Ê¶ÇÂøµÁöÑÂÖ≥ÈîÆË¶ÅÁÇπ',
          'ÊÄªÁªì‰∏Ä‰∏ãÊàë‰ª¨Â≠¶Âà∞ÁöÑÁü•ËØÜ'
        ]
      }
    }
    
    return concepts
  }

  // ÁîüÊàêÈùôÊÄÅËßÜËßâÊïàÊûúÔºàÂ§áÁî®ÊñπÊ°àÔºâ
  generateStaticVisuals(question, script) {
    console.log('üìä ÁîüÊàêÈùôÊÄÅËßÜËßâÊïàÊûú...')
    return [{
      sceneId: 1,
      animationType: 'static',
      videoPath: null,
      duration: 15,
      mathContent: question,
      script: script
    }]
  }
} 